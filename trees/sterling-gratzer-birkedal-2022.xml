<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" href="forest.xsl"?>
<tree expanded="true" show-heading="true" show-metadata="true" toc="false" root="false"><frontmatter> <anchor>166</anchor>  <taxon>Reference</taxon> <addr>sterling-gratzer-birkedal-2022</addr> <source-path>/Users/yangzx/Documents/forest/trees/refs/sterling-gratzer-birkedal-2022.tree</source-path> <route>sterling-gratzer-birkedal-2022.xml</route> <date><year>2022</year> <month>10</month> <day>6</day></date> <authors><author><link href="jonmsterling.xml" type="local">Jon Sterling</link></author><author><link href="danielgratzer.xml" type="local">Daniel Gratzer</link></author><author><link href="larsbirkedal.xml" type="local">Lars Birkedal</link></author> </authors> <title>Denotational semantics of general store and polymorphism</title> <meta name="doi">10.48550/arXiv.2210.02169</meta><meta name="bibtex">@unpublished{sterling-gratzer-birkedal-2022,
  author = {Sterling, Jonathan and Gratzer, Daniel and Birkedal, Lars},
  year = {2022},
  month = jul,
  note = {Unpublished manuscript},
  title = {Denotational semantics of general store and polymorphism},
}</meta></frontmatter> <mainmatter><p>We contribute the first denotational semantics of polymorphic dependent type theory extended by an equational theory for general (higher-order) reference types and recursive types, based on a combination of guarded recursion and impredicative polymorphism; because our model is based on <em>recursively defined semantic worlds</em>, it is compatible with polymorphism and relational reasoning about stateful abstract datatypes. We then extend our language with modal constructs for proof-relevant relational reasoning based on the <em>logical relations as types</em> principle, in which equivalences between imperative abstract datatypes can be established synthetically. Finally we develop a decomposition of the store model as a general construction that extends an arbitrary polymorphic call-by-push-value adjunction with higher-order store, improving on <link href="paulblainlevy" type="external">Levy</link>'s possible worlds model construction; what is new in relation to prior typed denotational models of higher-order store is that our Kripke worlds need not be syntactically definable, and are thus compatible with relational reasoning in the heap. Our work combines recent advances in the operational semantics of state with the purely denotational viewpoint of <em>synthetic guarded domain theory</em>.</p></mainmatter> <backmatter><contributions/> <context/> <related/> <backlinks><tree expanded="false" show-heading="true" show-metadata="true" toc="false" root="false"><frontmatter> <anchor>167</anchor>  <taxon>Blog</taxon> <addr>zyang-0002</addr> <source-path>/Users/yangzx/Documents/forest/trees/zyang-0002.tree</source-path> <route>zyang-0002.xml</route> <date><year>2023</year> <month>9</month> <day>25</day></date> <authors><author><link href="zyang.xml" type="local">Zhixuan Yang</link></author> </authors> <title>Relations as types</title> </frontmatter> <mainmatter><p>I have been learning about <link href="https://www.jonmsterling.com/jms-005T.xml" type="external">Synthetic Tait Computability (STC)</link> for a while and recently I read the paper <link href="sterling-gratzer-birkedal-2022.xml" type="local" title="Denotational semantics of general store and polymorphism">Denotational semantics of general store and polymorphism</link>. Among many other cool things, one technique I learnt from this paper is <b>relations as types</b>: the authors use a type theory iGDTT<tex>_{ \mathrm{LRAT} }</tex> to talk about relations in another type theory iGDTT — a type <tex>R</tex> in iGDTT<tex>_{ \mathrm{LRAT} }</tex> denotes a 'proof-relevant relation', or <em>span</em>, of types <tex>A_L  \leftarrow  A_C  \rightarrow  A_R</tex> in iGDTT, and there are ways inside iGDTT to talk about spans of the shape <tex display="block">A_L  \leftarrow   \emptyset   \rightarrow   \emptyset   \quad \text{or} \quad   \emptyset   \leftarrow   \emptyset   \rightarrow  A_R,</tex> which correspond to types in iGDTT.</p><p>Inside iGDTT<tex>_{ \mathrm{LRAT} }</tex>, the authors managed to define a type <tex>\tilde{L} A</tex> representing the <em>bisimilarity</em> relation between two possibly divergent computations of <tex>A</tex>-values, and then an element of this type <tex>\tilde{L} A</tex> amounts to a proof that two computations are bisimilar. This technique is very useful for constructing complex relations, as it allows us to treat relations naively as types while retaining the powerful to talk about 'real types' in the same language.</p><p>However, the setting of this paper, iGDTT, which stands for <em>impredicative Guarded Dependent Type Theory</em>, is quite involved as a type theory supporting <em>impredicative universes</em> and <em>guarded recursion</em>. But these things are in fact orthogonal to the idea of <em>relations as types</em>, so <mark>I'd like to write a blog post to explain this idea more explicitly in a much simpler setting — relations on ordinary sets.</mark></p><p>I will assume that the reader has some basic familiarity with dependent type theory and <em>category with families</em> (CwFs), for which a very instructive reference is <link href="martinhofmann.xml" type="local" title="Martin Hofmann">Martin Hofmann</link>'s <link href="hofmann-1997.xml" type="local" title="Exposition">exposition</link> (not to be confused with Chapter 2 of his PhD thesis under the same title). I will explicitly calculate the semantics of the types in a simple presheaf category, so this post might also be useful for people (like myself) who are learning <link href="https://www.jonmsterling.com/jms-005T.xml" type="external">STC</link> and find it difficult to calculate the semantics of the types in a general Grothendieck topos.</p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>1</crumb></trail> <anchor>168</anchor>   <addr>zyang-0005</addr> <source-path>/Users/yangzx/Documents/forest/trees/zyang-0005.tree</source-path> <route>zyang-0005.xml</route> <date><year>2023</year> <month>9</month> <day>26</day></date> <authors><author><link href="zyang.xml" type="local">Zhixuan Yang</link></author> </authors> <title>The category of spans of sets</title> </frontmatter> <mainmatter><p>Let's start by recalling some basic facts and intuition about spans of sets. Readers who know the idea that spans of sets are proof-relevant binary relations and they are just presheaves on the diagram <tex>L  \xrightarrow{l}  C  \xleftarrow{r}  R</tex> can entirely skip this section after having a look at our <link href="zyang-0006.xml" type="local" title="Notation">notation</link>.</p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>1</crumb> <crumb>1</crumb></trail> <anchor>169</anchor>  <taxon>Definition</taxon> <addr>zyang-0004</addr> <source-path>/Users/yangzx/Documents/forest/trees/zyang-0004.tree</source-path> <route>zyang-0004.xml</route> <date><year>2023</year> <month>9</month> <day>26</day></date> <authors><author><link href="zyang.xml" type="local">Zhixuan Yang</link></author> </authors> <title>Spans of sets</title> </frontmatter> <mainmatter><p>A <em>span</em> <tex>A</tex> of sets consists of three sets <tex>A_L</tex>, <tex>A_C</tex>, <tex>A_R</tex> and two functions <tex>A_l : A_C  \to  A_L</tex> and <tex>A_r : A_C  \to  A_R</tex>: <tex display="block">A_L  \xleftarrow{A_l}  A_C  \xrightarrow{A_r}  A_R.</tex>A morphism of spans <tex>h : A  \to  B</tex> consists of three functions <tex>h_L : A_L  \to  B_L</tex>, <tex>h_C : A_C  \to  B_C</tex>, and <tex>h_R : A_R  \to  B_R</tex> making the following diagram commute:
<center><img src="resources/f8e81e6e62bc64f2d58f852e21565dd1-web.svg"/></center>The category of spans of sets and their morphisms is denoted by <tex>\mathbf{Sp} ( \mathbf{Set} )</tex>.</p></mainmatter> </tree><p>In this post, I will just write <tex>\mathbf{Sp}</tex> for <tex>\mathbf{Sp} ( \mathbf{Set} )</tex>.</p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>1</crumb> <crumb>2</crumb></trail> <anchor>170</anchor>  <taxon>Intuition</taxon> <addr>zyang-0008</addr> <source-path>/Users/yangzx/Documents/forest/trees/zyang-0008.tree</source-path> <route>zyang-0008.xml</route> <date><year>2023</year> <month>9</month> <day>26</day></date> <authors><author><link href="zyang.xml" type="local">Zhixuan Yang</link></author> </authors> <title>Spans</title> </frontmatter> <mainmatter><p>The intuition for a span <tex>A</tex> is that it is a <em>proof-relevant relation</em> between the sets <tex>A_L</tex> and <tex>A_R</tex>: every element <tex>p  \in  A_C</tex> is a proof that <tex>A_l(p)</tex> and <tex>A_r{(p)}</tex> is related. In case the pairing function <tex>{ \left \langle   A_l, A_r   \right \rangle }  : A_C  \to  A_L  \times  A_R</tex> is <link href="https://ncatlab.org/nlab/show/injection" type="external"><em>injective</em></link>, the span <tex>A</tex> becomes a traditional proof-irrelevant relation — a pair of elements <tex>{ \left \langle   a, b   \right \rangle }   \in  A_L  \times  A_R</tex> is either related or not.</p></mainmatter> </tree><p>Following the intuition, we use the following notation in this post.</p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>1</crumb> <crumb>3</crumb></trail> <anchor>171</anchor>  <taxon>Notation</taxon> <addr>zyang-0006</addr> <source-path>/Users/yangzx/Documents/forest/trees/zyang-0006.tree</source-path> <route>zyang-0006.xml</route> <date><year>2023</year> <month>9</month> <day>26</day></date> <authors><author><link href="zyang.xml" type="local">Zhixuan Yang</link></author> </authors> <title>Notation for spans</title> </frontmatter> <mainmatter><p>For a span <tex>A</tex>, we define <tex>\mathsf{dom} _{ }  A  \coloneqq  A_L</tex> and <tex>\mathsf{cod} _{ } {A}  \coloneqq  A_R</tex>. Whenever <tex>p  \in  A_C</tex>, <tex>x = A_l(p)</tex> and <tex>y = A_r(p)</tex>, we write <tex>p : x  \mathrel{A}  y</tex> and say that <tex>p</tex> is a proof of <tex>x  \in   \mathsf{dom} _{ }  A</tex> and <tex>y  \in   \mathsf{cod} _{ }  A</tex> being related by <tex>A</tex>.</p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>1</crumb> <crumb>4</crumb></trail> <anchor>172</anchor>  <taxon>Intuition</taxon> <addr>zyang-0007</addr> <source-path>/Users/yangzx/Documents/forest/trees/zyang-0007.tree</source-path> <route>zyang-0007.xml</route> <date><year>2023</year> <month>9</month> <day>26</day></date> <authors><author><link href="zyang.xml" type="local">Zhixuan Yang</link></author> </authors> <title>Morphisms of spans</title> </frontmatter> <mainmatter><p>The intuition for a morphism of spans <tex>h : A  \to  B</tex> is that it is (1) a pair of functions <tex>h_L : A_L  \to  B_L</tex> and <tex>h_R : A_R  \to  B_R</tex> between the domains and codomains of the (proof-relevant) relations <tex>A</tex> and <tex>B</tex> together with (2) a function <tex>h_C : A_C  \to  B_C</tex> that maps proofs of <tex>x  \mathrel{A}  y</tex> to proofs of <tex>h_L(x)  \mathrel{B}  h_R(y)</tex>. When <tex>A</tex> and <tex>B</tex> are both proof-irrelevant, then a morphism <tex>h : A  \to  B</tex> is the same as two functions <tex>h_L</tex> and <tex>h_R</tex> sending related input to related output. Readers who have experience with <em>logical relations</em> or <em>partial equivalence relations</em> might find this situation familiar.</p></mainmatter> </tree><p>An important observation is that spans are the same as functors from the category <tex>\mathbf{S}</tex> to <tex>\mathbf{Set}</tex>, where <tex>\mathbf{S}</tex> is the category <tex>L  \xleftarrow{l}  C  \xrightarrow{r}  R</tex>, and morphisms of spans are the same as natural transformations. Therefore the category of spans <tex>\mathbf{Sp}</tex> is the exactly the presheaf category <tex>\mathbf{PSh} ( \mathbf{S} ^{ \mathsf{o} } )</tex> on <tex>\mathbf{S} ^{ \mathsf{o} }</tex>.</p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>2</crumb></trail> <anchor>173</anchor>   <addr>zyang-0009</addr> <source-path>/Users/yangzx/Documents/forest/trees/zyang-0009.tree</source-path> <route>zyang-0009.xml</route> <date><year>2023</year> <month>9</month> <day>26</day></date> <authors><author><link href="zyang.xml" type="local">Zhixuan Yang</link></author> </authors> <title>Dependent type theory in the category of spans</title> </frontmatter> <mainmatter><p>It is well known that presheaf categories are locally cartesian closed and thus are models for (extensional) <link href="https://ncatlab.org/nlab/show/Martin-Löf+dependent+type+theory" type="external"><em>Martin-Löf type theory</em></link> (MLTT). In this section, I will spell out the interpretation of MLTT in the presheaf category <tex>\mathbf{PSh} ( \mathbf{S} ^{ \mathsf{o} } )</tex> of spans. Instead of working with the syntactic rules of MLTT, we will directly work with <em>categories with families</em>, which are almost a direct algebraic reformulation of dependent type theories with explicit substitution. We record the definition here for completeness.</p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>2</crumb> <crumb>1</crumb></trail> <anchor>174</anchor>  <taxon>Definition</taxon> <addr>zyang-000G</addr> <source-path>/Users/yangzx/Documents/forest/trees/zyang-000G.tree</source-path> <route>zyang-000G.xml</route> <date><year>2023</year> <month>9</month> <day>27</day></date>  <title>Category with families</title> </frontmatter> <mainmatter><p>A <em>category with family</em> (CwF) consists of
<ul>  <li>a category <tex>\mathcal{C}</tex> with a terminal object,</li>  <li>a presheaf <tex>\mathbf{Ty}  :  \mathcal{C} ^{ \mathsf{o} }   \to   \mathbf{Set}</tex>,</li>  <li>a presheaf <tex>\mathbf{Tm}  :  ( \smallint   \mathbf{Ty} ) ^{ \mathsf{o} }   \to   \mathbf{Set}</tex> on the category of elements of <tex>\mathbf{Tm}</tex>,</li> 
  <li>for each <tex>\Gamma   \in   \mathcal{C}</tex> and <tex>A  \in   \mathbf{Ty} ( \Gamma )</tex>, a (fully specified) representing object for the following functor <tex>{ \mathcal{C} } _{ / \Gamma }   \to   \mathbf{Set}</tex><tex display="block">( \Delta   \xrightarrow{\gamma}   \Gamma )  \mapsto   \mathbf{Tm} ( \Delta ;  \mathbf{Ty} (f)(A)).
</tex></li></ul></p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>2</crumb> <crumb>2</crumb></trail> <anchor>175</anchor>  <taxon>Intuition</taxon> <addr>zyang-000H</addr> <source-path>/Users/yangzx/Documents/forest/trees/zyang-000H.tree</source-path> <route>zyang-000H.xml</route> <date><year>2023</year> <month>9</month> <day>27</day></date>  <title>Category with families</title> </frontmatter> <mainmatter><p>The objects in the category <tex>\mathcal{C}</tex> give semantics to the <em>contexts</em> of MLTT, and the morphisms <tex>\gamma  :  \Delta   \to   \Gamma</tex> in <tex>\mathcal{C}</tex> are semantic <em>substitutions</em>. Every element <tex>A</tex> of <tex>\mathbf{Ty} ( \Gamma )</tex> is a <em>type</em> in the context <tex>\Gamma</tex> that possibly depends on the variables in <tex>\Gamma</tex>. Every element <tex>e</tex> of <tex>\mathbf{Tm} ( \Gamma ; A)</tex> is a <em>term</em> of type <tex>A</tex> in the context <tex>\Gamma</tex>. The presheaf actions of <tex>\mathbf{Ty}</tex> and <tex>\mathbf{Tm}</tex> apply a substitution <tex>\gamma</tex> to types and terms in a context.</p><p>A fully specified representing object of the functor in the definition of CwFs is a morphism <tex>p :  \Gamma .A  \to   \Gamma</tex> together with a 'universal element' <tex>v  \in   \mathbf{Tm} ( \Gamma .A;  \mathbf{Ty} (p)(A))</tex>. The intuition for <tex>\Gamma .A</tex> is that it is the context extending <tex>\Gamma</tex> with a new variable of type <tex>A</tex>. The substitution <tex>p :  \Gamma .A  \to   \Gamma</tex> is the projection, and <tex>v</tex> is the term that is just the <em>variable</em> referring to the newly bound <tex>A</tex> in the context <tex>\Gamma .A</tex>.</p></mainmatter> </tree><p>CwFs formulate the bare bone structure for a dependent type theory without any type formers. Additional logical structures, corresponding to for example <tex>\Pi</tex> types and <tex>\Sigma</tex> types, can be further introduced, but we omit the precise definitions here and refer the reader to <mark>add ref</mark>.</p><p>The <em>initial (CwF with <tex>\Pi</tex>-types, <tex>\Sigma</tex>-types, identity types, <tex>W</tex>-types, universes)</em> is the syntactic model of MLTT. Therefore to interpret MLTT in a category <tex>\mathcal{C}</tex>, it is sufficient to define a CwF whose category of context is <tex>\mathcal{C}</tex>, which is what we are going to do for the category of spans.</p><p>First of all, we need a terminal object as the empty context. Initial and terminal objects, and more generally limits and colimits, in <tex>\mathbf{Sp}</tex> can be computed pointwise as follows.</p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>2</crumb> <crumb>3</crumb></trail> <anchor>176</anchor>  <taxon>Construction</taxon> <addr>zyang-000A</addr> <source-path>/Users/yangzx/Documents/forest/trees/zyang-000A.tree</source-path> <route>zyang-000A.xml</route> <date><year>2023</year> <month>9</month> <day>26</day></date> <authors><author><link href="zyang.xml" type="local">Zhixuan Yang</link></author> </authors> <title>Limits and colimits of spans</title> </frontmatter> <mainmatter><p>Limits and colimits in a functor category are computed pointwise, so the limit (and similarly for colimit) of a diagram <tex>F :  \mathcal{D}   \to   \mathbf{Sp}</tex> is 
<tex display="block">( \operatorname{lim} _{ i  \in   \mathcal{D} } Fi)_X =  \operatorname{lim} _{ i  \in   \mathcal{D} } (Fi)_X  \text{ for }  X  \in   \mathbf{S}</tex>which always exists when <tex>\mathcal{D}</tex> is small, since <tex>\mathbf{Set}</tex> is small-complete.
</p><p>In particular, the terminal object <tex>\mathbf{1} _{ }</tex> in <tex>\mathbf{Sp}</tex> is the span of singleton sets <tex display="block">\mathbf{1} _{ \mathbf{Set} }   \leftarrow   \mathbf{1} _{ \mathbf{Set} }   \rightarrow   \mathbf{1} _{ \mathbf{Set} } ,</tex> and the initial object <tex>\mathbf{0} _{ }</tex> in <tex>\mathbf{Sp}</tex> is the span of empty sets 
<tex display="block">\mathbf{0} _{ \mathbf{Set} }   \leftarrow   \mathbf{0} _{ \mathbf{Set} }   \rightarrow   \mathbf{0} _{ \mathbf{Set} } .</tex></p></mainmatter> </tree><p>The most natural way to interpret a type <tex>A</tex> that depends on a context <tex>\Gamma</tex> is a morphism <tex>p :  { \llbracket   A   \rrbracket }   \to   { \llbracket   \Gamma   \rrbracket }</tex> (<link href="seely-1984.xml" type="local" title="Seely 1984">Seely 1984</link>), and applying a substitution <tex>\gamma  :  \Delta   \to   \Gamma</tex> to the type <tex>{ \Gamma   \vdash   A }</tex> is interpreted as pulling <tex>p</tex> back along <tex>{ \llbracket   \gamma   \rrbracket }</tex>:</p><center><img src="resources/e2fde03bb14ebd383242211c0b821cf2-web.svg"/></center><p>And then type connectives are interpreted as various categorical structures in the slice category <tex>{ \mathbf{Sp} } _{ / { \llbracket   \Gamma   \rrbracket } }</tex>. For example, the product type <tex>{ \Gamma   \vdash   A  \times  B }</tex> is interpreted as the product of <tex>p :  { \llbracket   A   \rrbracket }   \to   { \llbracket   \Gamma   \rrbracket }</tex> and <tex>q :  { \llbracket   B   \rrbracket }   \to   { \llbracket   \Gamma   \rrbracket }</tex> in <tex>{ \mathbf{Sp} } _{ / { \llbracket   \Gamma   \rrbracket } }</tex> (which is the same as a pullback in <tex>\mathbf{Sp}</tex>).</p><p>However, a subtle problem that is well known now is that substitution on syntax <em>strictly</em> commutes with many other operations, while pullbacks in a category only commute with other operations <em>up to isomorphism</em>. For example, on syntax <tex>{ \Delta   \vdash   \gamma (A  \times  B) }</tex> is definitionally equal to <tex>{ \Delta   \vdash   \gamma (A)  \times   \gamma (B) }</tex>, but their interpretations in the category <tex>\mathbf{Sp}</tex> if we follow the recipe above are only isomorphic but not necessarily strictly equal. In fact, such coherence issues arise without any type formers: syntactic substitution is strictly associative and unital, but pullbacks are associative and unital only up to isomorphism.</p><p>Therefore, the interpretation of types above in a context <em>does not</em> work, since it doesn't validate some of the equations in the syntax model. There are multiple ways to fix this problem (<mark>add refs</mark>). In this post we will use one way that makes use of <em>universes of small spans</em> in <tex>\mathbf{Sp}</tex>.</p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>2</crumb> <crumb>4</crumb></trail> <anchor>177</anchor>   <addr>zyang-000D</addr> <source-path>/Users/yangzx/Documents/forest/trees/zyang-000D.tree</source-path> <route>zyang-000D.xml</route> <date><year>2023</year> <month>9</month> <day>27</day></date> <authors> <contributor><link href="zyang.xml" type="local">Zhixuan Yang</link></contributor></authors> <title>Universes of spans</title> </frontmatter> <mainmatter><p>A <em>Grothendieck universe</em> <tex>\mathcal{U}</tex> of sets is basically a set of sets closed under all the usual set theoretic operations. If a set <tex>A</tex> is contained in <tex>\mathcal{U}</tex>, we say that it is <tex>\mathcal{U}</tex>-small. We can also define <em>small spans</em> and <em>small span morphisms</em> as follows.</p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>2</crumb> <crumb>4</crumb> <crumb>1</crumb></trail> <anchor>178</anchor>  <taxon>Definition</taxon> <addr>zyang-000E</addr> <source-path>/Users/yangzx/Documents/forest/trees/zyang-000E.tree</source-path> <route>zyang-000E.xml</route> <date><year>2023</year> <month>9</month> <day>27</day></date> <authors><author><link href="zyang.xml" type="local">Zhixuan Yang</link></author> </authors> <title>Small spans and small span morphisms</title> </frontmatter> <mainmatter><p>For every <link href="https://ncatlab.org/nlab/show/Grothendieck+universe" type="external"><em>Grothendieck universe</em></link> <tex>\mathcal{U}</tex> of sets, we call a span <em><tex>\mathcal{U}</tex>-small</em> if its three constituting sets are all elements of <tex>\mathcal{U}</tex>. Moreover, a morphism of spans <tex>h : B  \to  A</tex> is called <tex>\mathcal{U}</tex>-small if for every <tex>p : x  \mathrel{A}  y</tex> the following span is <tex>\mathcal{U}</tex>-small:
<tex display="block">h_L^{-1}(x)  \xleftarrow{q  \mathrel{\mapsto}  B_l(q) }  h_C^{-1}(p)  \xrightarrow{q  \mathrel{\mapsto}  B_r(q)}  h_R^{-1}(y)</tex>where <tex>f^{-1}(x)</tex> denotes the inverse image of a function.
</p></mainmatter> </tree><p>The <link href="hofmann-streicher-1997.xml" type="local" title="Hofmann-Streicher lifting"><em>Hofmann-Streicher lifting</em></link> <tex>\dot{\mathcal{U}}</tex> of a Grothendieck universe <tex>\mathcal{U}</tex> of sets to the category of spans is the following span:
<tex display="block">\dot{\mathcal{U}}   \coloneqq   \left ( \mathcal{U}   \xleftarrow{\mathsf{dom} _{ }}   \mathcal{S} _ \mathcal{U}   \xrightarrow{\mathsf{cod} _{ }}   \mathcal{U}   \right ).</tex>where <tex>\mathcal{S} _ \mathcal{U}</tex> is the set of all <tex>\mathcal{U}</tex>-small spans. (Clearly, <tex>\dot{\mathcal{U}}</tex> itself is not <tex>\mathcal{U}</tex>-small.)</p><p>There is also a lifting of
the <em>pointed universe</em> <tex>\mathcal{U} ^ \bullet   \coloneqq   { \left \{ { \left \langle   X, x   \right \rangle }   \mid  X  \in   \mathcal{U} , x  \in  A \right \} }</tex> to the category of spans, which is 
<tex display="block">\dot{\mathcal{U}} ^ \bullet   \coloneqq   \left ( \mathcal{U} ^ \bullet   \leftarrow   { \left \{ { \left \langle   A, p   \right \rangle }   \mid  A  \in   \mathcal{S} _ \mathcal{U} , p  \in  A_C \right \} }   \rightarrow   \mathcal{U} ^ \bullet   \right )</tex>where the two legs of the span are respectively
<tex display="block">{ { \left \langle   A,p   \right \rangle }   \mapsto   { \left \langle   \mathsf{dom} _{ } A, A_l(p)   \right \rangle } }  \quad \text{and} \quad  { { \left \langle   A,p   \right \rangle }   \mapsto   { \left \langle   \mathsf{cod} _{ } A, A_r(p)   \right \rangle } }.</tex>There is an evident morphism <tex>\pi  :  \dot{\mathcal{U}} ^ \bullet   \to   \dot{\mathcal{U}}</tex> of spans that projects out the first components.</p><p>The universal property of Hofmann-Streicher lifting <tex>\mathcal{U}</tex> is that it <em>weakly classifies</em> <tex>\mathcal{U}</tex>-small morphisms: for every <tex>\mathcal{U}</tex>-small morphism <tex>h : B  \to  A</tex> of spans, there exists a (not necessarily unique) pullback square:</p><center><img src="resources/83be07f0e75cd84350ebeb3ddfed998e-web.svg"/></center><p>And conversely, every such pullback square satisfies that <tex>h</tex> is <tex>\mathcal{U}</tex>-small. To see this, we can make a specific choice of pulling back <tex>\pi</tex> along a morphism <tex>k : A  \to   \dot{\mathcal{U}}</tex> as follows:</p><p>We define <tex>k^*( \dot{\mathcal{U}} ^ \bullet )</tex> to be the span
<tex display="block">\begin{gather*} { \left \{ { \left \langle   x, x'   \right \rangle }   \mid  x  \in  A_L, x'  \in  k_L(x) \right \} }   \\ \uparrow   \\ { \left \{ { \left \langle   p, p'   \right \rangle }   \mid  p  \in  A_C, p'  \in  (k_C(p))_C  \right \} }   \\ \downarrow \\ { \left \{ { \left \langle   y, y'   \right \rangle }   \mid  y  \in  A_R, y'  \in  k_R(y) \right \} } \end{gather*}</tex>where the left leg is <tex>{ \left \langle   p, p'   \right \rangle }   \mapsto   { \left \langle   A_l(p), (k_C(p))_l(p')   \right \rangle }</tex> and the right leg is similar. This definition makes sense because the naturality of <tex>k</tex> ensures that <tex>k_L(x)</tex> and <tex>(k_C(p))_L</tex> are the same set for every <tex>p : x  \mathrel{A}  y</tex>. We define the map <tex>k^*( \pi ) : k^*( \dot{\mathcal{U}} ^ \bullet )  \to  A</tex> to be the evident map that projects out the first component. It can be quickly checked that <tex>k^*( \pi )</tex> is a pullback of <tex>\pi</tex> along <tex>k</tex> and it is <tex>\mathcal{U}</tex>-small:</p><center><img src="resources/37a12f7951d0bc2bd097eec3e752b8d6-web.svg"/></center></mainmatter> </tree><p>Assuming that there is a Grothendieck universe <tex>\mathcal{U}</tex>, we can fix the problem with coherence of substitution by interpreting types <tex>A</tex> in a context <tex>\Gamma</tex> as morphisms <tex>{ \llbracket   A   \rrbracket }  :  { \llbracket   \Gamma   \rrbracket }   \to   \dot{\mathcal{U}}</tex>, and then semantic substitution becomes <em>precomposition</em>: given a context substitution <tex>\gamma  :  \Delta   \to   \Gamma</tex>, its action <tex>{ \Delta   \vdash   \gamma (A) }</tex> on a type <tex>{ \Gamma   \vdash   A }</tex> is interpreted as simply
<tex display="block">{ \llbracket   A   \rrbracket }   \circ   { \llbracket   \gamma   \rrbracket }  :  { \llbracket   \Delta   \rrbracket }   \to   \dot{\mathcal{U}} .</tex>This immediately solves the coherence issue of associativity and unitality of substitution as morphism composition is associative and unital. If we can further make sure that our type operations on <tex>\mathbf{hom} _{ } ( { \llbracket   \Gamma   \rrbracket } , \dot{\mathcal{U}} )</tex> — which we will show shortly — also commute with precomposition then the coherence issue with substitution is fixed.</p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>2</crumb> <crumb>5</crumb></trail> <anchor>179</anchor>   <addr>zyang-000F</addr> <source-path>/Users/yangzx/Documents/forest/trees/zyang-000F.tree</source-path> <route>zyang-000F.xml</route> <date><year>2023</year> <month>9</month> <day>27</day></date>  <title>The CwF structure of spans</title> </frontmatter> <mainmatter><p>We can complete the definition of the CwF structure on the category <tex>\mathbf{Sp}</tex> of spans as follows :
<ul>  <li>The category of <b>contexts</b> and substitutions is <tex>\mathbf{Sp}</tex>.</li> 
  <li>The set of <b>types</b> over a context <tex>\Gamma   \in   \mathbf{Sp}</tex> is
<tex display="block">\mathbf{Ty} ( \Gamma )  \coloneqq   \mathbf{hom} _{ } ( \Gamma , \dot{\mathcal{U}} ) .</tex>The action of a substitution <tex>\gamma  :  \Delta   \to   \Gamma</tex> on <tex>\mathbf{Ty} ( \Gamma )</tex> is <tex display="block">( {-}   \circ   \gamma ) :  \mathbf{Ty} ( \Gamma )  \to   \mathbf{Ty} ( \Delta ).</tex></li>  <li>The set of <b>terms</b> over a type <tex>A :  \Gamma   \to   \dot{\mathcal{U}}</tex> is 
<tex display="block">\mathbf{Tm} ( \Gamma ; A)  \coloneqq   { \left \{ e :  \Gamma   \to  A^*( \dot{\mathcal{U}} ^ \bullet )  \mid  A^*( \pi )  \circ  e =  1 _{ } \right \} } ,</tex>where <tex>A^*</tex> is the chosen pullback of <tex>\pi</tex> in the definition of <link href="zyang-000D.xml" type="local" title="Universes of spans">universes of spans</link>:
  <center><img src="resources/6e68f758c9718b4c6eb7924363f9fc41-web.svg"/></center>The action of a substitution <tex>\gamma  :  \Delta   \to   \Gamma</tex> on <tex>\mathbf{Tm} ( \Gamma ; A)</tex> sends every <tex>e :  \Gamma   \to  A^*( \dot{\mathcal{U}} ^ \bullet )</tex> to the following morphism in <tex>\mathbf{Tm} ( \Delta , A  \circ   \gamma )</tex> <tex display="block">{ \left \langle   1 _{ \Delta } , k  \circ  e  \circ   \gamma   \right \rangle }  :  \Delta   \to  (A  \circ   \gamma )^*( \dot{\mathcal{U}} ^ \bullet )</tex> using the pullback property of <tex>(A  \circ   \gamma )^*( \dot{\mathcal{U}} ^ \bullet )</tex>:
<center><img src="resources/9aacb706f82b71807aaefe0192f6a8ad-web.svg"/></center></li>  <li><b>Context extension</b> for a type <tex>A :  \Gamma   \to   \dot{\mathcal{U}}</tex> is just the chosen pullback <tex>\Gamma .A  \coloneqq  A^*( \dot{\mathcal{U}} ^ \bullet )</tex>. The associated context projection is <tex display="block">p  \coloneqq  A^*( \pi ) :  \Gamma .A  \to   \Gamma ,</tex> and the variable projection is <tex display="block">v  \coloneqq   { \left \langle   1, k   \right \rangle }   \in   \mathbf{Tm} ( \Gamma .A; A  \circ  p)</tex> given by the pullback property of <tex>\Gamma .A.(A  \circ  p)</tex> as in the following diagram:
</li></ul></p><center><img src="resources/21dc8d758dc2aa4941058a6d0d698e3e-web.svg"/></center><p>The reader might have noticed that the CwF structure above doesn't depend on anything specific to <tex>\mathbf{Sp}</tex> but works for any category with any morphism <tex>\pi  :  \dot{\mathcal{U}} ^ \bullet   \to   \dot{\mathcal{U}}</tex> that has chosen pullbacks along all morphisms. The property of <tex>\dot{\mathcal{U}}</tex> as a universe will be used later when defining type formers on the CwF of spans.</p></mainmatter> </tree></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>3</crumb></trail> <anchor>180</anchor>   <addr>zyang-000I</addr> <source-path>/Users/yangzx/Documents/forest/trees/zyang-000I.tree</source-path> <route>zyang-000I.xml</route> <date><year>2023</year> <month>9</month> <day>30</day></date> <authors><author><link href="zyang.xml" type="local">Zhixuan Yang</link></author> </authors> <title>Future directions</title> </frontmatter> <mainmatter><p>Relational calculus is notoriously difficult to work with for equational reasoning about programs in the style of <link href="aop.xml" type="local" title="The algebra of programming">the algebra of programming</link>. It seems embedding relations in a topos as we have done here is a good idea to simplify this. However, we haven't tackled two fundamental operations on relations/span in this post:</p><ul><li>This first one is <em>composition</em> of relations/spans, which seems definable using the STC connectives.</li><li>The second one is taking the <em>converse</em> of relations/spans, which flips the left leg and right leg of a relation/span. This is an involutive functor on <tex>\mathbf{Sp}</tex> but it is not a strong functor, so it cannot be directly internalised as a functor inside the language of <tex>\mathbf{Sp}</tex>. Instead, we need to use some form of modal type theory to handle it.</li></ul></mainmatter> </tree></mainmatter> </tree></backlinks> <references/></backmatter></tree>